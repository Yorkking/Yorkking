---
title: Redis学习-入门_数据类型
tags:
 - Redis
---

## 多元数据库

Redis是一个字典结构的存储服务器，实际上一个 Redis 实例提供了多个用来存储数据的字典，客户端可以指定将数据库存储在哪个字典中。

每个数据库对外都是一个从 0 开始的递增数字命名， Redis 默认支持 16 个数据库，可以通过配置参数 databases 来修改这一数字。可以使用 SELECT 命令来更换数据库.

每个数据库都以编号命名，不支持自定义的数据库名字。另外，Redis 也不支持为每个数据库也没有权限访问，要么全访问，要么一个都不可以访问。多个数据库之间并不是完全隔离的，比如 FLUSHALL 命令可以清空 Redis 实例中所有的数据库中的数据。 

## 启动

这里是在个人的 WSL 上安装了Redis, 所以是在命令行下和 Redis 交互。

启动 Redis 的服务器：[]表示[]内的语句可以省略，是一个可选参数。

```bash
redis-server [--port 6379]
```

进入交互界面（另开一个终端）

```bash
redis-cli [command]
```

## 入门_数据类型

### 1. 字符串类型

- 赋值和取值

    ```Redis
    SET key value
    GET key
    ```

- 递增数字

  ```Redis
  INCR key
  ```

- 命令拾遗：
  - INCRBY key increment
  - DECR key
  - DECRBY key decrement
  - INCRBYFLOAT key increment 增加浮点数

- 向尾部追加值

  - APPEND key value, 如果键不存在，则将键的值设置为value, 返回追加后字符串的总长度。

    双引号区分空格；

- 获取字符串的长度
  
- STRLEN key, 不存在返回0。这里的长度是指 UTF-8 编码在的长度；
  
- 同时获得/设置多个键值：
  - MGET key [key ...]
  - MSET key value [key value ...]

- 位操作：

  - GETBIT key offset

  - SETBIT key offset value

  - BITCOUNT key [start] [end] (字节)，获取是1的二进制位个数

  - BITOP operation destkey key [key ...]，

    eg: BITOP OR res foo1 foo2

> 命名规则：
>
> ![rule](/assets/image/image-20200410102657664.png)

### 2. 散列类型

散列类型（hash）的键值也是一种字典结构，其存储了字段（field) 和字段值的映射，但字段值只能是字符串，不支持其他数据类型，即散列类型不能嵌套其他数据类型。一个散列数据类型键可以包含至多 $2^{31}-1$ 个字段。

散列类型时候存储对象：使用对象类别和 ID 构成键名，是哟字段表示对象的属性，而字段值则存储属性值。

> 优点：
>
> - 关系数据库中存储这种半结构化的数据需要额外的表才行；
> - 然而，Redis 的散列则不存在这个问题，对于每个对象的存储结构，可以不一样。

#### 命令

1. **赋值和取值**

   这些命令应该很好记，也很好理解：

   ```Redis
   HSET key field value
   HGET key field
   HMSET key field value [field value ...]
   HMGET key field [field ...]
   HGETALL key
   ```

2. 判断字段是否存在: 存在返回 1， 否则返回 0，键值不存在也会返回 0 。

   ```Redis
   HEXISTS key field
   ```

3. 当字段不存在时赋值

   ```Redis
   HSETNX key field value
   ```

   与 HSET 命令类似，区别于如果字段已经村子，HSETNX 命令将不执行任何操作；

4. 增加数字

   ```Redis
   HINCRBY key field increment
   ```

5. 删除字段

   ```Redis
   HDEL key field [field ...]
   ```

### 3. 列表类型

列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，活着获得列表的某一个片段。

列表类型内部是使用双向链表（double linked list）实现的。好处：可以快速的访问头尾的一些元素，加入新元素不影响之前的，但代价是索引访问可能会慢。适用场景：社交网站的新鲜事。适合用来记录日志。

一个列表类型键，最多容纳 $2^{32}-1$个元素。

### 命令

1. 向列表两端增加元素

   ```Redis
   LPUSH key value [value ...] // 向左加入
   RPUSH key value [value ...] // 向右加入
   ```

2. 从列表两端弹出元素

   ```Redis
   LPOP numbers	// 列表左边弹出一个元素：移除元素，并返回移除的元素
   RPOP numbers	// 列表右边弹出一个元素
   ```

3. 获取列表中元素的个数

   ```Redis
   LLEN key //这个操作的复杂度为O(1)
   ```

4. 获得列表片段

   ```Redis
   lrange key start stop //注意包含最右端的元素，即stop包含
   ```

   支持负索引，表示从右边开始计数；

   - 如果 start 索引的位置比 stop 索引位置靠后，则会返回空列表
   - 如果是 stop 大于实际的索引范围，则会返回到列表最右边的元素；

5. 删除列表中指定的值

   ```Redis
   lrem key  count value
   ```

   命令会删除列表中前 count  个值为 value 的元素，返回值是实际删除的元素个数。

   - 当 count >0 时，lrem 命令会删除前count 个值为 value 的元素
   - count < 0时，lrem 命令会从列表右边开始删除前 |count | 个值为 value 的元素。

美中不足的是：

- 没有类似字符串那样的 MGET 命令，每次访问一个键，都要向数据库请求一次，产生一次往返时延，**不过可以利用管道和脚本优化这个问题**。

#### 命令拾遗

1. 获得/设置指定索引的元素值。

   ```Redis
   lindex key index  //获得键 key 对应的 index 索引的值
   lset key index value
   ```

2. 只保留列表指定片段

   删除指定索引范围之外的所有元素，包含最右边元素。

   ```Redis
   ltrim key start end
   ```

3. 向列表中插入元素

   ```Redis
   linsert key before|after pivot value
   ```

   首先，会在列表中从左到右查找到值为 pivot 的元素，然后根据第二个参数  before or after 来决定将 value 插入到后面还是前面。

4. 将元素从一个列表转移到另一个列表

   ```Redis
   rpoplpush source destination
   ```

   把列表类型作为队列使用时，rpoplpush 命令可以很直观地在多个队列中传递数据。如果source 和 destination 相同时，那么可以不断把队尾的元素移动到队首。


### 3. 集合类型

集合中每个元素都是不同的，且没有顺序。一个集合类型（set）键可以存储至多 $2^{31}-1$ 个字符串。

常用操作是向集合中加入或删除元素、判断某个元素是否存在等等。集合类型在 Redis 内部是使用值为空的散列表 ( hash table) 实现的，所以这些操作的时间复杂度都是 O(1)。

#### 命令

1. 增加/删除元素

   ```Redis
   sadd key member [member ...]
   srem key member [member ...]
   ```

   第一条是增加元素，返回值是成功加入的元素数量。

   第二条是删除元素，返回值是成功删除的元素数量。

2. 获得集合中的所有元素

   ```Redis
   smembers key
   ```

3. 判断元素是否在集合中

   ```Redis
   sismember key member
   ```

   存在时，返回1；否则，返回0。

4. 集合间的运算

   ```Redis
   sdiff key [key ...]
   sinter key [key ...]
   sunion key [key ...]
   ```

   1. sdiff 命令用来对多个集合执行差集运算。集合 A 和集合 B 的差集表示为 A-B，代表所有属于 A 且不属于 B 的元素的构成。
   2. sinter 执行多个集合的交集运算。
   3. sunion 命令用来对多个集合执行并集运算。

5. 命令拾遗：

   1. 获得集合中的元素个数:

   ```Redis
   scard key
   ```

   2. 集合运算存入键

   ```Redis
   sdiffstore destination key [key ...]
   sinterstore destination key [key ...]
   sunionstore destination key [key ...]
   
   ```

   3. 随机获得集和中的元素

   ```Redis
   srandmember key [count]
   ```

   随机获取\|count\|个元素，count省略时，默认返回一个。

   - count > 0, 随机返回 count 个不同的元素
   - count < 0, 随机返回 \|count\|个元素，可能相同；

   4. 从集合中弹出一个元素

      ```Redis
      spop key
      ```

      随机弹出一个元素。

### 4. 有序集合类型

sorted set。

在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数。

有序集合和列表类型的区别：

- 列表类型是通过链表实现的，获取接近两端的数据速度极快
- 有序集合类型是使用散列表和跳跃表实现的，所以即使读取之间部分的数据速度也很快（复杂度是O(logN)
- 列表不能简单得调整某个元素的位置，但是有序集合可以（通过改这个元素的分数）。
- 有序集合要比列表类型更耗费内存。

#### 命令

1. 增加元素

    ```Redis
    zadd key score member [score member]
    ```

分数不仅可以是整数，也支持双精度浮点数；+inf，-inf也可以

2. 获得元素的分数

   ```Redis
   zscore key member
   ```

3. 获得排名在某个范围的元素列表

   ```Redis
   zrange key start stop [withscores]
   zrevrange key start stop [withscores]
   ```

   zrange 命令会按照元素分数从小到大的顺序返回索引从start 到 stop 之间所有元素。

   zrevrange从大到小；

4. 获得指定分数范围的元素

   ```Redis
   zrangebyscore key min max [withscores] [limit offset count]
   ```

5. 增加某个元素的分数

   ```Redis
   zincrby key increment member
   ```

#### 命令拾遗

1. 获得集合中元素的数量

   ```Redis
   zcard key
   ```

2. 获得指定分数范围内的元素个数

   ```Redis
   zcount key min max
   ```

3. 删除一个或多个元素

   ```Redis
   zrem key member [member ...]
   ```

   返回值是成功删除的元素数量。

4. 按照排名范围删除元素

   ```Redis
   zremrangebyrank key start stop
   ```

   zremrangebyrank 命令按照元素分数从小到大的顺序删除处在指定排名范围内的所有元素，并返回删除是元素数量。

5. 按照分数范围删除元素

   ```Redis
   zremrangebyscore key min max
   ```

   返回的是删除的元素数量。

6. 获得元素的排名

   ```Redis
   zrank key member
   zrevrank key member
   ```

   从 0 开始，即最小的排名为 0。

7. 计算有序集合的交集

   ```Redis
   zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max ]
   ```

   返回值为 destination 键中的元素个数。

   