---
title: 408知识内容
tags:
 - 计算机综合
---

## 计算机组成原理

1. 浮点数的加减，对阶，溢出问题

   浮点数：阶符，阶码| 数符，尾数。

   规格化的浮点数：

   - 定义：充分利用尾数的有效位数，即规定最高位数位是一个有效值。
   - 左规：尾数算术左移，即小数点不动，尾数左移，直观上数变大了，阶码就要减小。
   - 右规：尾数算术右移（一般是尾数溢出时，需要进行操作），即小数点不动，尾数右移，直观上数变小了，阶码就要增加。
   - 无论补码还是原码表示尾数，规格化后符号位和最高位必定不同。
   - 上溢出：往负无穷或正无穷方向
   - 下溢出：往0方向。

   754标准:

   1,8,23, 127。1-254

   1,11,52, 1023

2. 主存，Cache 的映射，以及回写（Write Back) 和直写（Write Through) 方式

   Cache: 按数据块和主存交换数据，存的是实实在在的数据；

   Cache 一行一行划分，每一行里面的数据的长度称为行长；

   Cache 组成：

   - 有效位
     - 还可能有脏位（比如使用写回法的时候），替换控制位
   - 标记号
   - 数据

   $| 有效位，脏位，替换控制位 | 标记号 | 数据块 |$

   映射方式：

   - 直接映射：内存中每一块只能装入 Cache 中唯一位置，采用字节低位决定放到某一行；空间利用率最低；
   - 全相联：Cache 每个位置直接和对应的存储器位置用线连起来，然后需要顺序进行比较；
   - 组相联：m 路组相联，是说每组有 m 个行。组内采用全相联映射。

   写策略：

   - 写命中时：
     - 全写法：write through, 即写缓存的时候，也写回内存；
     - 写回法：write back, 即只写缓存，被换出时再写回内存，需设置脏位，即表示该数据是否被CPU修改过；
   - 写未命中时：
     - 写分配法：加载主存中块至缓存，然后更新缓存。所以这种方法和写回法配合使用；
     - 非写分配法：直接更新内存，不对缓存做调块处理。配合全写法使用。（靠读操作把该块调入缓存）

3. 存储器交叉编址

   属于双端口、多模块的内容。

   双端口：

   - 多个CPU访问同一个RAM, 考虑冲突：写冲突，读写冲突，读读不冲突，前提是访问地址相同。

   多模块：

   - 主要思想：同时从存储器中取出 n 条指令。

   - 单体多字，一个地址存多条指令。只有一个存储体。

   - 多体交叉，多个存储体。

     - 高位交叉：本质就是多个存储体并成一个存储体而已，就是高地址选中一个存储体，然后低位地址表示在选中的存储体内的地址，就是一个顺序的存储体；

     - 低位交叉：就是低位用来选中存储器，（交叉的含义，大概就是低位上连线连到所有存储体上，所以就交叉了吧），高位用来表示存储体内地址。其实也是顺序，不过就是存储器按行来连续了。即 addr % m 的值来选中，可以使得连续地址分布在不同存储器上，可以进行流水线访问。

       模块存取一个字的周期为 T, 总线传输周期为 r，则为了实现流水线方式，存储器的个数 m >= T/r。

       总线周期 r 就是，存储体占用总线传送数据的时间，这个表达式的意思就是说，当第一个存储器没有被存取完之前，需要有足够的存储体来接受 CPU 发出的地址访问，可以类比计算机网络里面的滑动窗口协议。 

4. TLB 方式，就是逻辑地址映射这一块要重点掌握：要做到计算快，且准确。

5. 补码和原码数值对应关系：

   M 为一个补码，二进制形式为 101111……01；怎么快速求出其对应的 10 进制值呢？如果是正数直接求，但是如果是负数呢？

   用最高位符号位当作数值，$\sum_{i=0}^{n-2}a_i2^i  - signed * 2^{n-1}$, n 位的补码.

   补码和移码关系：符号位取反即完成转换。
   
6. MAR寄存器的位数：是由主存空间大小相对应的，换句话说，应该是MAR寄存器的位数决定了主存空间最大大小，它的位数与实际内存大小无关！！

7. 总线：

   系统总线的结构：

   - 单总线结构：

     - 单总线结构将 CPU, 主存，I/O 设备都挂在一组总线上，允许 I/O 设备之间、I/O 设备与主存之间直接交换信息。就是相当于所有设备连接一组线上，那么一个所有设备都只能互斥的使用总线。
       - 成本低，易于接入新设备

   - 双总线结构：

     - 以 CPU 为中心：一条是主存总线，CPU和主存，以及通道之间传数据；另一条是 I/O 总线，用于设备和通道之间传数据；

   - 三总线结构：

     以存储器为中心：

     - 主存总线：CPU 和存储器之间
     - I/O 总线（系统总线）：CPU和各种外设之间通信
     - 存储总线（DMA总线）：设备和主存之间。

   计算机是时钟频率由两种：内频率和外频率。内频率是与CPU相关的频率，外频率是I/O等控制器的总线频率等等。而且，一般内频率是外频率的整数倍。另外，个人基本认为：时钟周期（时钟频率的倒数）是最小的节拍单位。另外无论啥周期都是时钟周期的整数倍。另外，需要明白 CPU 的时钟周期基本指得是时钟周期，换句话说，时钟周期就是指 CPU 的时钟周期，内频率基本就是指主频。这和CPU的指令周期有啥区别？

   - 指令周期应该是时钟周期的整数倍；即执行一条指令所需的总时间，为时钟周期的整数倍；

8. SPOOLing 技术

   假脱机技术。以空间换时间的技术。

   输入数据通过内存的输入缓冲区然后送到输入井；然后CPU处理输入的数据，直接从输入井内取数据，处理完毕又送到磁盘上的输出井里。然后外围设备需要数据时，从输出井上读数据到输出缓冲区，然后送到外围设备上。

9. 中断

   中断的过程：中断分内中断和外中断。

   几个基本的概念：

   - 中断服务程序：就是为啥要中断啊，中断的目的就是去执行别的程序，那个别的程序就是中断服务程序。

   - 中断向量：就是指 cs,ip 构成的一个**数据**，它的数据指示的是欲执行的程序的起始地址，这个欲执行的程序就是中断服务程序，这个**起始地址**也称**中断服务程序入口地址**。
   - 中断向量的地址：即指向中断向量；
   - 中断服务程序的入口地址：即中断向量保存的内容，见上两条。

   中断是怎么产生的呢？整个过程是怎样？

   先说外中断：

   - 首先，我们知道 CPU 的指令执行的周期中，有一个**中断周期**，在中断周期，CPU会**检查是否有中断信号产生**（以x86处理器为例，处理器会检查**来自 NMI 线**(不可屏蔽中断)和 **INTR（可屏蔽中断）线**上的信号），并且结合位于**CPU内部**的 **FLAGS 寄存器**中 **IF 标志**位的状态值是否为 1 来判断是否响应中断（当然，非屏蔽中断上的信号若产生，则需要响应，不受 IF 的影响），若响应，首先**保存当前程序的地址**（即cs,ip，也就是PC的内容），然后这个时候 CPU 结合中断的类型号（这个信息的获取估计是靠传过来的 INTR 或 NMI 线上的信息来的？当然，貌似是通过一种称为 8259A 的芯片，该芯片上会记录中断源产生的中断的各种信息？这里，不太清楚，所以只是猜想……）**得到中断向量的地址**，然后从中断向量里面**取出中断服务程序的入口地址**，**跳转至它进行执行**。

     然后具体谈谈这个过程做了哪些事情：

     - 中断隐指令的过程：**保存当前程序的 PC**（一般是保存在栈上），同时需要**保存 PSW寄存器**（emmmm, 貌似实际的 x86 处理器中，对应的汇编中这个寄存器是叫 **FLAGS 寄存器的，也叫标志寄存器**，因为 PSW 叫程序状态字貌似在操作系统里面可以指代一个程序的状态字，是指一个程序所有的通用寄存器的组合，反正感觉怪怪的，好像每本书说法不一……），然后寻找到中断向量，并**取出**里面的内容，即**中断服务程序的入口地址**，**并跳转**之 (jmp)。
     - 中断服务程序：现在到了中断服务程序，
       - 首先，保护现场（是保存上一个程序，即被中断的那个程序的现场信息，比如通用寄存器组的信息，一般保存至进程控制块PCB里面）
       - 开中断（当然，这是允许嵌套中断才要，如果涉及嵌套中断就需要考虑中断的优先级了，所以相应的中断屏蔽字可能也需要更新，所以可能有一个送中断屏蔽字的过程）
       - 服务处理
       - 关中断
       - 恢复现场（以及屏蔽字）
       - 开中断
       - 中断返回

   再说内中断：

   - 是由 CPU 内部执行过程中直接产生的，什么意思？一般是一些程序主动的行为或者是异常行为；

     - 主动行为：比如程序访问一个系统调用，其实内部原理是基于中断实现的（因为涉及内核态和用户态之间的切换几乎都是靠中断实现的），比如退出进程吧，int 23(好像是这个)，就是程序主动发起一个中断，或者说让CPU直接执行一条中断语句，这个过程其实和上面差不多，并没有太大差别。
     - 异常行为：比如程序缺页异常，出现除 0 异常，访问越界异常等等，程序就不能再继续正常往下执行了，然后将原来执行过程打断。

     多说一点，就个人经验而言，如果是这些内中断，其实服务中断程序都是由开发操作系统的人来写的，一般并不会包含上述的外中断的中断服务程序的全部过程，就比如数组访问越界异常，可能直接就是在服务程序那里直接让程序直接退出。

   另外，毫无疑问，内中断是肯定不能被屏蔽的，因为它是主动行为（就下一条语句就是这个）或者是严重的错误，如果执行想必会造成大麻烦，而且其优先级也是最高的。

## 操作系统

1. 位图表示法是啥?(操作系统里面的外存管理)：

   文件系统里面用来记录磁盘空间哪些块是否空闲的方法。每个盘块用一个 bit 表示，1 表示已分配。可以采用二维的形式，就是一个 bit<M,N> map 的数组，然后行和列表示第几个磁盘块，数值表示是否被分配。

   顺便提及一下其他几种空闲空间的管理方法：

   - 空闲表法：
     - 把磁盘块的按第一个空闲块的起始位置 Addr，以及以此为开始连续空闲块的个数N, 按Addr 的递增顺序存在一个表里面。然后操作系统给文件分配空间的方法可以采用最佳适配、首次适配、最坏适配、当前首次适配等方法；
   - 空闲链表法：
     - 把所有空闲盘块组成一个链表，分配时只需要取下相应的块给用户，然后在链表上删除这些块。回收时，把磁盘块链接到表尾。
   - 成组链接法：
     - 以上的空闲表和空闲链表法都不适应于大型文件系统。UNIX 结合这两种方法，大致思想为：第0个空闲扇区不存实际的空闲位置，而是存储另外的 n 个空闲扇区的地址，可以理解成一种索引（类似与 Unix 里面的一级索引块），然后第二层的 n 个空闲扇区，然第 n 个重复第 0 个的操作，另外的 n-1 个直接存真正的空闲块的地址。然后依次类推，直到把所有空闲位置全部链接起来。

2. 磁盘的扫描算法，以及寻找到一个特定扇区时间的计算；

   一次磁盘平均读写操作时间：

   $T = T_{寻道} + T_{延迟} + T_{传输时间}$

   $T_{延迟}$ 为转一圈的时间的一半，平均时间嘛。

   $T_{传输时间} $ 取决于磁头旋转经过某个扇区是时间。

   磁盘扫描算法，是针对寻道而言：

   - FCFS: 先来先服务，谁先来服务谁，公平
   - SSTF: 最短时间优先，离当前磁头就近的优先，不公平，可以产生饿死；
   - SCAN,(电梯算法)：就是规定磁头的移动方向，在当前磁头方向上离它最近的优先，对最近扫过的区域不公平。还有Look 优化，即不用走到磁头终点，走到最右的一个请求即可；
   - CSCAN：优化一下，到达终点后，不是返回，而是迅速走到初始磁头位置，然后开启下一次的 SCAN 算法。偏向处理最外或最离的那些请求。



3. 页面分配策略：

   操作系统给进程页面分配的策略：

- 固定分配，局部置换。就是给定一个进程固定的页框数，每次调页只对它自己拥有的页面数进行置换；
- 可变分配，全局置换。操作系统自身维护一个全局内存空闲的页框表，每次进程需要引入新的页时，直接从页框表中取下一个分配给它；
- 可变分配，局部置换。先预先给定一个进程一定数目的页框数，开始时缺页时只是在进程已经分配的那些页框里面进行置换，如果发现进程的缺页率升高，则从全局内存空闲表里取下一定数目的页框给它。



4. 虚拟存储器

   要和文件管理区分开来，虚拟存储器虽然也是和文件一样是针对外存而言，但是虚拟存储器本质是针对内存而言的，即针对进场的内存管理，这是需要注意的。

   虚拟存储只能基于非连续分配技术。

5. I/O 是数据总线

   I/O 数据总线上传数据。CPU对I/O控制命令也是通过数据总线来进行

   I/O 控制总线只传送读/写信号。（其实也是显然的，因为I/O接口中含有译码器，不可能CPU直接把控制信号直接传给I/O设备，否则需要I/O译码器做什么？）

6. I/O 接口的层次执行
   - 用户级I/O软件
   - 设备无关软件层
   - 设备驱动程序
   - 中断处理程序
   - 硬件
   
7. 处理机啥时候能调度的问题：
   
   - 进行结束时可以，创建可以，处于临界区也可以，系统调用完成并返回用户态时也可以
   
8. 双缓冲区的复习：

   这个需要花一些时间来详细了解，并且把它的计算过程弄流畅！！！

   

## 数据结构

1. 森林，树转换成二叉树的规则：

   - 树转化成二叉树规则：

     - 根的第一个左孩子，依次和它的兄弟节点进行连接，然后除第一个左孩子，其余兄弟节点断开与其父亲节点的连接。然后此时的子树(即以左孩子为根的）绕着左孩子为轴，顺时针旋转45°，即可。

   - 森林转换成二叉树：

     - 把森林中每一颗树转换成二叉树，然后以第一棵树的根节点为根节点，把第二棵树的根节点连到第一棵树上，第三棵连到第一棵，..., 第 n 棵连到第 n-1 棵的根上。

       它们构成一棵树，然后利用转二叉树的方法把它们转换成二叉树即可。（实际上只需要以第一棵树的根为轴心顺时针旋转45°即可）

   它们遍历的对应关系：

   - 树的先根遍历，对应二叉树的先序遍历
   - 树的后根遍历，对应二叉树的中序遍历
   - 森林的先序遍历：对应二叉树先序遍历
   - 森林的中序遍历：对应二叉树的中序遍历

2. 图的度：
   
   - 有向图和无向图的度
   
3. **AOE网的问题**

   Activity on Edge: 找出所有的关键路径，缩短包含在所有关键路径上的活动的时间可以缩短工期。

   还是没有了解清楚这个。我觉得还是详细了解一下AOE为好，就彻底掌握它。

   具体的操作：

   - 首先，找到源点（入度为0）和汇点（出度为0）
   - 然后利用修改过的拓扑排序算法来求解以下的一些量：
     - 每个节点的**最早开始时间** ve[...]，每个节点的最晚开始时间 vl[...]
       - 具体怎么做呢？首先，ve[0] = 0, 假设 0 号节点是源点，从源点出发。
       - 然后对于之后的每一个节点 i（拓扑排序会选出，当前节点负责更新 以它出发的有向边 连接的另一端的节点 j 的 ve[] 值），更新为 $ve[j] = \max(ve[j], ve[i] + w_{i\rightarrow j}), w 为边权重$。
     - 求完了最早开始时间后，再逆向拓扑(也不用逆向，正向也行）求解**最迟开始时间**：
       - 汇点的 vl[n-1] = ve[n-1], 假设 n-1 为汇点的
       - 对于一个节点 i, 找到和它有有向边的节点 j，且节点 i 是作为有向边的发出一端。则 $ vl[i] = \min(vl[i], ve[j] - w_{i\rightarrow j})$ 
   - 之后，求解事件（即边）的最早开始时间 ee[] 和最晚开始时间 el[]
     - 边$w_{i \rightarrow j }$ (这里 $w$ 既表示权重，也表示边本身）的最早开始时间 $ee_{w_{i\rightarrow j}} = ve[i]$, 最晚开始时间 $el_{w_{i\rightarrow j}} = vl[j] - w_{i \rightarrow j}$
   - 最后判定关键活动：
     - 关键活动（就是边）就是那些边的最早时间和最晚时间相等的边所对应的活动；
     - 关键路径：一条从源点到汇点的简单路径，且路径上所有的边代表的活动均是关键活动。

4. 基数排序，以及各种排序的问题

   基数排序算法的基本原理：简单来说就是按位比较的思想。比如给定一系列整数，假设均为3位，那么可以先比较个位，按个位比较排一次序（过程就是，构造 10 个链表，编号从0-9，然后依次把数按照它们的个位 num % 10 = i 填入到第 i 个链表中。然后按需把链表中所有数按头至尾串起来），然后按十位、按百位排序，完成之后，整个数据就有序了。

   稳定的，空间复杂度：O(r), (r 为链表数)，时间复杂度O(d(n+r)), d为趟数，与序列起始状态无关。

   冒泡排序：

   - 基本思想是：每次从最后面选一个数，一直往前进行冒泡，使小的数一直往前走的去（就是每次和前一个数比较，如果前面更大就交换位置，让小的数一直往前走，大的往后挪）。

     **也可以反过来！每次大的往后冒泡啊！！**
   
     ```C++
     void bubleSort(vector<int>& arr){
         bool flag = false;
         for(int i=0;i<arr.size()-1;++i){
             flag = false;
             for(int j=arr.size()-1;j>i;j--){
                 if(arr[j-1]>arr[j]){
                     swap(arr[j-1],arr[j]);
                     flag = true;
                 }
             }
             if(!flag) return; // 没有发生交换，说明已经有序，直接返回
         }
     }  
     ```

  

   - 选择排序

     基本思想：第 i 次选择出第 i 小的元素。
   
     ```C++
     void selectSort(vector<int>& arr){
         for(int i=0;i<arr.size()-1;i++){
             int minIndex = i;
             for(int j=i+1;j<arr.size();++j){
                 if(arr[j]<arr[minIndex]){
                     minIndex = j;
                 }
             }
             if(i != minIndex) swap(arr[i],arr[minIndex]);
         }
     }
     ```



5. 还有查找

   折半查找法的二叉判定树。

   

6. 归并排序：

   - 每个段都有序。

7. AVL 树的操作：

   - RR 旋转：竟然是左单旋转！
   - LL 旋转：竟然是右单旋转！
   - LR: 正常的左单选右旋转，反正一定涉及三个节点，其中第三个节点是要被转上去了。
     - 旋转轴首先是对第三个节点而言，其中旋转对象是第二个节点；
     - 最后的右旋，还是以第三个节点为轴，然后旋转对象为第一个节点。 
   - RL旋转：同LR旋转。

8. 哈夫曼树：

   - 最小带权和的树，可能有多颗，是一种二叉树，不一定是完全二叉树。
   - 具体而言：
     - 每次选取权值之和最小的两个节点，然后构造它们的父节点，其中左右孩子节点顺序没有规定。

9. 多级页表

   - 顶级页表最多占一个页。
   - 顶级页表和二级页表的页大小相同
     - 页表项是不是也是一样呢？
   - 记住规则即可：二级页表的拥有多少页框是由一级页表的表项数决定的。
   - 二级页表的拥有的表项数就是进程最多拥有的页框数。

10. 页表的映射方式：

    或者Cache的映射方式，一定要搞清楚啊！！！！

    - 标记，脏位，算法控制位，数据等等。

      其中映射到哪一个块的那部分数据是不用存的！！！
    
11. 三对角矩阵：

    对角矩阵也称为带状矩阵。三对角矩阵：非零元素全部集中在三条对角线上。

12. 关于缺失率的计算：

    - 首先要明确进行了访存的次数 N；
    - 然后再计算缺失的次数 M
    - M/N，即为缺失率。

## 计算机网络

1. 计算机网络里面，那个数据链路的带宽到底怎么算的问题。

   - 各种协议下如何计算，选择性重传（SR), GBN，停等协议；

     计算方法，均考虑第一帧从发出到收到确认的这段时间T0。为什么这样？因为无论是选择性重传还是滑动窗口协议，都是采用流水线方式，那么流水线方式就意味着可以一下子发送很多，比如 N 帧，而只有当第一帧收到确认后，才能下一次发送第 N+1 帧，可以想象成如果第 N 帧未被确认，后续第 N+1 帧就会被阻塞一样，所以是这样。

     根据以上分析，$T_0 = RTT + T_{传输延迟}$。

   - 另外，几个协议的的序号问题：

     - GBN: 接收窗口大小为1，n 比特的编号，发送窗口大小 W_T:

       1 <= W_T <= 2^n - 1;

     - SR选择性重传，接收窗口不为1；

       W_s = W_r;

       W_s = 2^(n-1);

   - 信道利用率：发送了比特的时间/一个发送时间周期；是一个百分比；

   - 信道的吞吐量 = 信道利用率 * 发送方的发送速率；

   - 还是这个问题，它会变形，求知少的帧号位数，这里就需要考虑发最短的帧还是最长的帧，显然应该发最小的帧，这样才能多发。

2. HDLC 协议

   遇到连续 5 个 1 就在后面插入0， 它的帧的标志字段为 01111110

3. OSI七层模型：

   从上至下为：

   - 应用层
   - 表示层
   - 会话层
   - 传输层
   - 网络层
   - 数据链路层
   - 物理层

4. 各类应用使用的协议：

   数据链路层：

   - CSMA/CD, CSMA/CA，属于MAC 控制子层。
   - PPP 协议、HDLC 协议，SR等协议，属于 LLC 子层。

   网络层：

   - IP 协议
   - IGMP 协议（网络组播管理协议）
   - OSPF 协议 (属于内部网关协议，它自己又可以分区)
   - ARP 协议
   - ICMP 协议（网际控制报文协议），PING 命令直接使用了 ICMP (但 PING 工作在应用层)，Traceroute 工作在网络层

   传输层：

   - UDP/TCP

   应用层：

   - RIP (UDP): 距离向量路由协议，属于 IGP (内部网关协议)
   - BGP (TCP)：边界网关协议，属于 EGP (外部网关协议)
   - DHCP协议（UDP)
   - DNS (UDP)
   - SNMP(UDP)


5. 奈奎斯特采样定理

   无噪声情况下，极限带宽 $2*W \log_2V$ (bps)
   
   香农定理：$W* \log_2(1+S/N) bps$, 其中 $S/N$ 是信道的传输信号的平均功率/ 高斯噪声的功率，其中定义 $10\log_{10}(S/N)$ 为信噪比，单位为 dB，即 10dB，对应 S/N = 10, 30dB时，为S/N = 1000.
   
6. ICMP报文类型：有两种：差错报告报文和 ICMP 询问报文。

   其中差错报告报文用于报告差错和异常情况：有以下 5 中类型：

   - 终点不可达：主机或路由器不能交付数据报，就像源点发送终点不可达报文
   - 源点抑制。路由器或主机由于拥塞而丢弃数据报时，限制源点的发送数据
   - 时间超时：TTL减为零
   - 参数问题：
   - 改变路由（路由重定向）：发现更好的路由

7. 以太网的帧：

   最短是 64 B，其中数据部分为 64B - 18B = 48B

   最长是 1500B + 18B，其中数据部分为 1500B。
   
8. TCP协议：

   TCP协议是面向字节流的，虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把从应用程序交付下来的数据视为无结构的数据流。

   